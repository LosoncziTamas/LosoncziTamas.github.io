---
layout:     post
title:      Implementing a level selector grid
date:       2020-02-17
author:     Tam√°s Losonczi
categories: Unity3D
tags:
 - unity
 - ui
---

# Implementing a level selector grid

## First version
The simplest version uses `ScrollView` UI element combined with a `ContentSizeFitter` and a `GridLayoutGroup` component. 
Since I wanted to replicate a level selector grid I applied the following configs.
I set the _Vertical Fit_ parameter to _Min Size_ so the content expands according to the number of elements.

_image_

Additionally there are two custom scripts: `LevelSelector` and `LevelSelectorItem`, along with a corresponding LevelSelectorItem prefab, which features a Text, a Button, and an Image component.

```
    public class LevelSelector : MonoBehaviour
    {
        [SerializeField] private LevelSelectorItem _selectorItemPrefab;
        [SerializeField] private RectTransform _content;

        private List<ItemData> _items = new List<ItemData>();

        public class ItemData
        {
            public readonly Action<ItemData> onClick;
            public readonly string levelText;

            public ItemData(Action<ItemData> onClick, string levelText)
            {
                this.onClick = onClick;
                this.levelText = levelText;
            }
        }

        private void Clear()
        {
            _items.Clear();
            foreach (Transform child in _content.transform)
            {
                Destroy(child.gameObject);
            }
        }

        public void SetItems(List<ItemData> itemsToAdd)
        {
            _items.AddRange(itemsToAdd);
            foreach (var item in _items)
            {
                Instantiate(_selectorItemPrefab, _content.transform).Init(item);
            }
        }

        private void OnDestroy()
        {
            Clear();
        }
    }
```

`LevelSelector` maintains a list of `ItemData`, instantiantes and destroyes objects.

```
    public class LevelSelectorItem : MonoBehaviour
    {
        [SerializeField] private Text _text;
        [SerializeField] private Button _button;
        
        private LevelSelector.ItemData _data;
                
        public void Init(LevelSelector.ItemData data)
        {
            _data = data;
            _text.text = data.levelText;
        }

        private void OnEnable()
        {
            _button.onClick.AddListener(HandleClick);
        }

        private void OnDisable()
        {
            _button.onClick.RemoveListener(HandleClick);
        }

        private void HandleClick()
        {
            _data?.onClick.Invoke(_data);
        }
    }
```

In some cases this is fine, for example when you know that the number of items will be relatively small and you won't make changes frequently in the data set. However, there are some potential problems with this version.

## Potential pitfalls & issues
- Wrong item can get selected in the grid.
  - This can happen when the child is taking more size then specified cell size in the `Grid Layout Group`. 
- Removal of items is error-prone and not performant.
  - Consider a situation where you may want to clear the list first, and then add new items to the grid. However, since `Destroy()` is not called instantaneously but after the current Update loop, the newly added items will be also destroyed.
- Large number of items are not handled efficently.
  - Items are destroyed and created each time the data set changes. 
- Harder to identify which item gets selected (one string field may not be sufficient to differentiate an item from the rest)

## Second version
To tackle the unneccesary creation and destroyal of objects we could use a pool which buffers and returns object on demand.

```
    public class LevelSelectorPool : MonoBehaviour
    {
        [SerializeField] private LevelSelectorItem _itemPrefab;
            
        private readonly Stack<LevelSelectorItem> _pooledObjects = new Stack<LevelSelectorItem>();

        public LevelSelectorItem GetItem()
        {
            LevelSelectorItem result;
            
            if (_pooledObjects.Count > 0)
            {
                result =  _pooledObjects.Pop();
            }
            else
            {
                result = Instantiate(_itemPrefab);
            }
            result.transform.SetParent(null);
            result.gameObject.SetActive(true);

            return result;
        }

        public void ReturnItem(LevelSelectorItem toReturn)
        {
            toReturn.gameObject.SetActive(false);
            toReturn.transform.SetParent(transform);
            _pooledObjects.Push(toReturn);
        }

        public void Clear()
        {
            foreach(var item in _pooledObjects)
            {
                Destroy(item);   
            }
            _pooledObjects.Clear();
        }
    }
```

Accordingly we update the `LevelSelector` to use the pool foor retrieving and to return items.

```
    public class LevelSelector : MonoBehaviour
    {
        [SerializeField] private LevelSelectorItem _selectorItemPrefab;
        [SerializeField] private RectTransform _content;
        [SerializeField] private LevelSelectorPool _pool;

        private List<ItemData> _items = new List<ItemData>();

        public class ItemData
        {
            public readonly Action<ItemData> onClick;
            public readonly string levelText;
            public readonly object dataRef;

            public ItemData(Action<ItemData> onClick, string levelText, object dataRef = null)
            {
                this.onClick = onClick;
                this.levelText = levelText;
                this.dataRef = dataRef;
            }
        }

        private void Clear()
        {
            _items.Clear();
            while (_content.childCount > 0)
            {
                var child = _content.GetChild(0);
                _pool.ReturnItem(child.GetComponent<LevelSelectorItem>());
            }
        }

        public void SetItems(List<ItemData> itemsToAdd)
        {
            Clear();
            _items.AddRange(itemsToAdd);
            foreach (var itemData in _items)
            {
                var itemInstance = _pool.GetItem();
                itemInstance.Init(itemData);

                var itemTransform = itemInstance.transform;
                itemTransform.SetParent(_content.transform);
                itemTransform.localScale = Vector3.one;
            }
        }

        private void OnDestroy()
        {
            Clear();
        }
    }
```

Make sure you set the scale explicty because parenting and unparenting can mess up the size of the child.

## Notes regarding the updated version

- Each time when you add just want to add a new item, Clear() is called which removes the entire hierarchy.
- The number of game objects could drastically grow while they only a subset is visible to the user.


## Relevant notes
- Create canvas
- Add Scroll View object
  - It's window that you can scroll up and down
  - Removing the horizontal Scroll ()
- Use the rect transform tool to modify in the scene view.
- Viewport/Content item
  - This is what is being scrolled.
  - We want to use a fixed size based on the elements in the grid.
- Add Grid layout group component to Content
  - Cell size defines the size of elements
  - Vertical fit to min size.
- Add content size fitter
  - This components makes more room if needed (when items are populated as children).
  - PopulateGrid script which creates items randomly.
- Create a dummy item prefab (an image)
